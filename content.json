{"meta":{"title":"hicode","subtitle":"愿你出走半生 归来仍是少年","description":"A blog about software engineering, data science and algorithms","author":"hicode","url":"https://hicode360.github.io","root":"/"},"pages":[{"title":"categories","date":"2021-09-27T08:54:47.000Z","updated":"2022-11-27T14:44:19.000Z","comments":true,"path":"categories/index.html","permalink":"https://hicode360.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-09-27T08:55:32.000Z","updated":"2022-11-27T14:43:33.000Z","comments":true,"path":"tags/index.html","permalink":"https://hicode360.github.io/tags/index.html","excerpt":"","text":""},{"title":"about","date":"2021-09-27T09:02:54.000Z","updated":"2022-11-27T13:58:20.000Z","comments":true,"path":"about/index.html","permalink":"https://hicode360.github.io/about/index.html","excerpt":"","text":"A blog about software engineering, data science and algorithms"}],"posts":[{"title":"docker常用命令","slug":"git&sql&docker/docker常用命令","date":"2022-11-27T14:28:39.000Z","updated":"2022-11-28T02:54:52.000Z","comments":true,"path":"20221127222839/git&sql&docker/docker常用命令/","link":"","permalink":"https://hicode360.github.io/20221127222839/git&sql&docker/docker%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"docker常用命令12345678910111213141516docker pull tensorflow/serving #从仓库拉取镜像docker pull tensorflow/serving:latest-gpu #从仓库拉取GPU镜像docker pull tensorflow/serving:2.8.3-gpu #从仓库拉取GPU镜像docker run -it tensorflow/serving #进入到镜像中exit #退出镜像docker run tensorflow/serving #运行某个容器docker ps // 查看所有正在运行容器docker stop containerId // containerId 是容器的IDdocker ps -a // 查看所有容器docker ps -a -q // 查看所有容器IDdocker stop $(docker ps -a -q) // stop停止所有容器docker rm $(docker ps -a -q) // remove删除所有容器docker rm/rmi #删除容器/镜像docker cp local_files containerId:docker_files #本地文件复制到docker tf-serving部署123456789101112-p: 指定主机到docker容器的端口映射--mount: 表示要进行挂载,其中 type=bind: 是选择挂载模式， source: 要部署模型的存储路径，也就是挂载的源（必须是绝对路径）， target: 要挂载的目标位置，模型挂载到docker容器中的位置，也就是docker容器中的目录（放在集装箱的哪里）-t: 指定的是挂载到哪个容器-e: 环境变量 MODEL_NAME: 必须与target指定路径的最后一个文件夹名称相同--per_process_gpu_memory_fraction: 运行时所需的GPU显存资源最大比率的值设定-v: path1:path2 分别指模型在机器种储存的路径（必须是绝对路径），模型在容器中储存的路径（放在集装箱的哪里） 1234docker run -p 8500:8500 \\ --mount type=bind,source=/Users/coreyzhong/workspace/tensorflow/saved_model/,target=/models/test-model \\ -t tensorflow/serving:1.15.0 \\ -e MODEL_NAME=test-model --model_base_path=/models/test-model/ &amp; 12345model_path=&quot;/Users/havorld/jupyter/model_save/&quot;docker run -t --rm -p 8500:8500 -p 8501:8501 \\ -v &quot;$model_path/din:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/serving &amp; 1234567查看TensorFlow-Serving状态： curl http://localhost:8501/v1/models/$&#123;model_name&#125;查看TensorFlow-Serving模型信息： curl http://localhost:8501/v1/models/$&#123;model_name&#125;/metadata查看模型信息: saved_model_cli show --dir=&#x27;./$&#123;model_path&#125;/20220422104620&#x27; --all使用Http请求进行模型预测： curl -d &#x27;&#123;&quot;instances&quot;: [1,2,3,4,5]&#125;&#x27; -X POST http://localhost:8501/v1/models/$&#123;model_name&#125;:predict其中instances的value为模型输入Tensor的字符串形式，矩阵维度需要和Tensor对应。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586docker run -t --rm -p 8501:8501 \\ -v &quot;/home/Personas/havorld/tfserving/tf_saved_models:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/servingdocker run -t --rm -p 8501:8501 \\-v &quot;/Users/haopeng.meng/jupyter/tf_saved_models:/models/tf_saved_models&quot; \\-e MODEL_NAME=tf_saved_models \\tensorflow/servingcat /opt/logs/rec-feed-api/access.log | grep &quot;feed recommend-&gt; uid:55&quot; | grep &quot;id=34174686&quot;sudo docker run -t --rm -p 8501:8501 -p 8500:8500 \\ -v &quot;/home/meng.haopeng/tfserving/tf_saved_models:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/servingdocker run -p 8501:8501 -p 8500:8500 \\ --mount type=bind,source=/Users/haopeng.meng/jupyter/tf_saved_models,target=/models/tf_saved_models \\ -e MODEL_NAME=tf_saved_models \\ -t tensorflow/servingdocker run -p 8500:8500 \\ --mount type=bind,source=./intent/,target=/models/intent_score \\ -e MODEL_NAME=intent_score -t tensorflow/serving:1.10.0docker run -p 8501:8501 -p 8500:8500 --mount type=bind,source=/my/model/path/m,target=/models/m -e MODEL_NAME=m -t tensorflow/serving:2.1.0sudo docker run -t --rm -p 8501:8501 -p 8500:8500 \\ -v &quot;/home/meng.haopeng/tfserving/tf_saved_models:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/serving#docker run -t -p 443:8500 -p 8500:8501 -v &quot;/data/lsj/dmp/SavedModel/:/models/&quot; tensorflow/serving --model_config_file=/models/models.config --model_config_file_poll_wait_seconds=300# run use containerdocker run -t -p 8501:8500 --name=tf_serving_multi_version_01 -v &quot;/data/tf-model/models/:/models/&quot; tensorflow/serving --model_config_file=/models/models.config --model_config_file_poll_wait_seconds=300 --allow_version_labels_for_unavailable_models=true --enable_batching=true --batching_parameters_file=/models/batch.config# tf-serving部署docker run -t --rm -p 8501:8501 \\-v &quot;/Users/haopeng.meng/jupyter/tf_saved_models:/models/tf_saved_models&quot; \\-e MODEL_NAME=tf_saved_models \\tensorflow/servingdocker run -p 8501:8501 -p 8500:8500 \\ --mount type=bind,source=/Users/haopeng.meng/jupyter/tf_saved_models,target=/models/tf_saved_models \\ -e MODEL_NAME=tf_saved_models \\ -t tensorflow/serving sudo docker run -t --rm -p 8501:8501 -p 8500:8500 \\ -v &quot;/home/meng.haopeng/tfserving/tf_saved_models:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/servingsudo docker run --name feed -t --rm -p 8700:8500 -p 8701:8501 \\ -v &quot;/home/meng.haopeng/tfserving/tf_saved_models:/models/tf_saved_models&quot; \\ -e MODEL_NAME=tf_saved_models \\ tensorflow/servingdocker run --name feed -t --rm -p 8701:8501 -p 8700:8500 \\ --mount type=bind,source=/home/Personas/havorld/tfserving/model_save,target=/models/model_save \\ -e MODEL_NAME=model_save \\ -t tensorflow/serving:latest-gpu docker run --name feed -t --rm -p 8700:8500 -p 8701:8501 \\ --mount type=bind,source=/Users/haopeng.meng/Desktop/recommend/rec-alg-feed/model_save/din/serving/,target=/models/serving \\ -e MODEL_NAME=serving \\ -t tensorflow/serving docker run --name feed -t --rm -p 8700:8500 -p 8701:8501 \\ --mount type=bind,source=/Users/haopeng.meng/Desktop/recommend/serving/din/,target=/models/serving \\ -e MODEL_NAME=serving \\ -t tensorflow/serving","categories":[{"name":"docker","slug":"docker","permalink":"https://hicode360.github.io/categories/docker/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hicode360.github.io/tags/docker/"},{"name":"tfserving","slug":"tfserving","permalink":"https://hicode360.github.io/tags/tfserving/"}]},{"title":"python中的数据类型","slug":"python/Python中的数据类型","date":"2022-11-27T14:11:18.000Z","updated":"2022-11-28T02:34:59.000Z","comments":true,"path":"20221127221118/python/Python中的数据类型/","link":"","permalink":"https://hicode360.github.io/20221127221118/python/Python%E4%B8%AD%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","excerpt":"","text":"Python中的数据类型可变数据类型对变量的值进行修改时，变量对应的内存地址不变，对应的值发生了改变，这种数据类型就称为可变数据类型。 不可变数据类型对变量的进行修改时，变量对应的内存地址发生了改变(变量指向了新的内存)，从而修改了变量的值，而变量对应的原内存的值并没有被改变，这种数据类型就称为可变数据类型。 也就是：不可变数据类型更改后地址发生改变，可变数据类型更改地址不发生改变 常用数据类型 数据类型 是否是可变数据类型 是否有序 None (空) 不可变 - int (整数) 不可变 - float (浮点) 不可变 - bool (布尔) 不可变 - str (字符串) 不可变 - tuple (元组) 不可变 序列类型，有序 list (列表) 可变 序列类型，有序 set (集合) 可变 序列类型，无序，不可重复 dict (字典) 可变 映射类型，v3.6及以后无有序, 前面版本无序 扩展 数据类型 是否是可变数据类型 是否有序 说明 bytes 不可变 - 定义字节：b’hello’,bytes(5) bytearray 可变 - 定义字节数组：bytearray(b’hello’), bytearray(10) complex (复数) 不可变 - 由一个实数和一个虚数组合构成，如：4+3j frozenset (冻结的set) 不可变 无序 冻结的set初始化后不能再添加或删除元素 array (数组) 可变 有序 数组中的元素必须是同一类型 OrderedDict 可变 有序 key有序，setdefault取值key不存在也不报错 defaultdict 可变 有序 取值时Key不存在也不会抛出KeyError异常 deque 可变 有序 高效插入和删除的双向队列列表 常见数据类型的操作和转换list列表[ ]list是**==可变==、==可重复==的==有序==**列表，里面的元素的数据类型也可以不同(也可以是另一个list)。list可根据索引号取其中的数据。 list的生成12345678list1 = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]print(&quot;list1: &quot;, list(list1)) # 输出： list1: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]list2 = list(range(0, 10))print(&quot;list2: &quot;, list(list2))list3 = [i*i for i in range(10) if i % 2 == 0]print(&quot;list3: &quot;, list(list3))list4 = (str(i) + j for i in range(0, 10, 2) for j in &quot;xyz&quot;)print(&quot;list4: &quot;, list(list4)) list元素反转、排序和次数统计12345678910list1 = [0, 1, 2, 3, 4, 5, 5, 5, 6, 7, 8, 9]list1.reverse() # 元素顺序反转print(&quot;list reverse: &quot;, list1)list1.sort(reverse=False) # 排序print(&quot;list sort: &quot;, list1)list1 = sorted(list1, reverse=True)print(&quot;list sort: &quot;, list1)times = list1.count(5) # 查看list中的元素出现的次数print(&quot;times: &quot;, times) list元素的添加、删除和取值12345678910111213141516list1.append(10)print(&quot;append value: &quot;, list1) # 添加元素list1.insert(1, 10) # 在指定位置添加元素print(&quot;insert value: &quot;, list1)list1.remove(10) # 删除指定value元素(第一个匹配的元素)print(&quot;remove value: &quot;, list1)value = list1.pop(12) # 删除指定index的元素并返回删除的值list1.pop() # 不指定index时默认删除最后一个元素list1.pop(-2) # 删除倒数第二个元素print(&quot;remove index: &quot;, list1)index_value = list1.index(3) # 查找第一个value为100的index值，如果不存在报TypeError异常print(&quot;index_value: &quot;, index_value)print(list1)index_value = list1.index(5, 7, 9) # 指定范围，从第7(包括)个到第9(不包括)个元素之间查找value为5的indexprint(&quot;index_value: &quot;, index_value) list添加多个元素、list的合并12345list2 = [100, 101, 102]# list1 = list1 + list2list1.extend(list2)print(list1)print(&quot;*&quot; * 10) list的遍历1234567891011for value in list1: print(&quot;value: %i&quot; % value)print(&quot;*&quot; * 50)for index in range(len(list1)): print(&quot;index: %i, value: %i&quot; % (index, list1[index]))print(&quot;*&quot; * 50)for index, value in enumerate(list1): print(&quot;index: %i, value: %i&quot; % (index, value))print(&quot;*&quot; * 50)for index, value in enumerate(list1, 100): # index从100开始 print(&quot;index: %i, value: %i&quot; % (index, value)) list中使用切片(slice)取值12345678910111213elements = list1[0:3] # 取第0到3条元素(包括头不包括尾)# elements = list1[:3]print(&quot;slice elements: &quot;, elements)elements = list1[1:] # 取第1到最后一个元素(包括头也包括尾)print(&quot;slice elements: &quot;, elements)elements = list1[-2] # 取倒数第二条print(&quot;slice elements: &quot;, elements)elements = list1[4:-2] # 取第四条到倒数第二条(包括头不包括尾)print(&quot;slice elements: &quot;, elements)elements = list1[0:6:2] # 取第0条到第6条中每2个取一个print(&quot;slice elements: &quot;, elements)elements = list1[:] # 取所有元素print(&quot;slice elements: &quot;, elements) ==列表、元组和字符串==都可以使用切片进行操作 list的深copy和浅copy12345678910111213141516# 浅拷贝只拷贝了引用，没有拷贝内容list2 = list1list2[1] = 1000print(&quot;list1: &quot;, list1)print(&quot;list2: &quot;, list1)print(id(list1), id(list2))# 深拷贝是对于一个对象所有层次的拷贝(递归拷贝)list3 = list1.copy()# import copy# list3 = copy.copy(list1)# list3 = copy.deepcopy(list1)list1[1] = 1print(&quot;list1: &quot;, list1)print(&quot;list3: &quot;, list3)print(id(list1), id(list3)) set集合{ }set是**==可变==**、==不可重复==的==无序==列表。 ==set中不可以放入可变对象==，因为无法判断两个可变对象是否相等而去重。 set的定义123456789101112131415161718192021222324set0 = &#123;0, 0, 1, 2, 3, 4, 5, 4, 5, 6&#125; # 直接定义set集合print(&quot;set0: &quot;, set0) # 输出 set0: &#123;0,1, 2, 3, 4, 5, 6&#125;set1 = set([0, 0, 1, 2, 3, 4, 5, 4, 5, 6]) # 通过list定义setprint(&quot;set1: &quot;, set1)set2 = set((0, 0, 1, 2, 3, 4, 5, 4, 5, 6)) # 通过tuple定义setprint(&quot;set2: &quot;, set2)set3 = set(&#123;&quot;x&quot;: 2, 10: &quot;b&quot;&#125;) # 通过dict定义setprint(&quot;set3: &quot;, set3) # 输出 set3: &#123;10, &#x27;x&#x27;&#125;my_list = [0, 0, 1, 2, 3, 4, 5, 4, 5]set4 = set(my_list) # set中不可以放入可变对象,然而为何放入list却不报错?print(&quot;set4: &quot;, set4) # 输出 set4: &#123;0, 1, 2, 3, 4, 5, 6&#125;# 由下面操作可以得出结论,set是先把list做遍历得到不可变的int对象类型后再放入set中my_list[0] = 10print(&quot;set4 with my_list changed: &quot;, set4) # 输出 &#123;0, 1, 2, 3, 4, 5, 6&#125;my_list.append([10, 20])print(&quot;my_list: &quot;, my_list)set5 = set(my_list) # 在list再放入list,此时将报错print(&quot;set5: &quot;, set5) set元素的添加、删除和取值12345678910111213141516set0 = &#123;0, 0, 1, 2, 3, 4, 5, 4, 5, 6&#125;print(&quot;set0: &quot;, set0)set0.add(&quot;cn&quot;) # 添加单个元素print(&quot;set0: &quot;, set0)set0.update([10, 20, 30]) # 添加多个元素print(&quot;set0: &quot;, set0)set0.add((&quot;com&quot;, &quot;cn&quot;)) # 添加元组(元组是不可变数据类型)print(&quot;set0: &quot;, set0)# set0.add([10, 20]) # 添加list报错,不能添加可变的数据类型(不能添加,但可以使用list创建set)# set0.add(&#123;10, 20&#125;) # 添加set报错,(可是使用不可变的frozenset添加:set0.add(frozenset(&#123;10, 20&#125;)))# set0.add(&#123;&quot;x&quot;: 2, 10: &quot;b&quot;&#125;) # 添加dict报错,不能添加可变的数据类型(不能添加,但可以使用dict创建set)set0.remove(&quot;cn&quot;) # 根据值删除元素(set不能根据索引删除)print(&quot;set0: &quot;, set0) set取并集和交集12345set1 = &#123;&quot;a&quot;, &quot;b&quot;, 4, 6, 100&#125;my_set = set0 | set1 # 取并集print(my_set)my_set = set0 &amp; set1 # 取交集print(my_set) set遍历注：set的遍历同list dict字典{ }dict是**==无序==，key==不可重复==、==不可变==**内容以key-value键值对形式存在的映射 dict中的key只能是不可变对象且唯一, 一个key对应一个value，多次对一个key设置value，后面的值会把前面的冲掉。 dict一般用在需要高速查找的很多地方。dict的key必须是不可变对象，这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这种通过key计算位置的算法称为哈希算法（Hash）。要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list、set是可变的，所以就不能作为key。 dict的创建和增删改查12345678910111213141516dict1 = &#123;&quot;addr&quot;: &quot;北京&quot;, &quot;age&quot;: 18, &quot;gender&quot;: &quot;女&quot;&#125;dict1[&quot;height&quot;] = 1.77 # 添加元素dict1.pop(&quot;age&quot;) # 删除元素输出item_del = dict1.popitem() # 产出dict中的最后一个item并返回print(&quot;item_del: &quot;, item_del)dict1[&quot;addr&quot;] = &quot;深圳&quot; # 修改元素print(&quot;dict1: &quot;, dict1)keys = dict1.keys() # 获取dict的所有keyprint(&quot;keys: &quot;, keys) # dict_keys([&#x27;add&#x27;, &#x27;height&#x27;])addr = dict1.get(&quot;addr&quot;) # 根据key获取value,若key不存在报异常(defaultdict字典不报异常)print(&quot;addr: &quot;, addr)addr = dict1.setdefault(&quot;addr&quot;) # 根据key获取value,若key不存返回None,也可设置默认返回值print(&quot;addr: &quot;, addr)name = dict1.get(&quot;name&quot;, &quot;unknow&quot;) # 根据key获取value,若key不存返回默认值&#x27;unknow&#x27;print(&quot;name: &quot;, name) dict的遍历12345678910# dict的遍历for key in dict1: print(&quot;key: %s, value: %s&quot; % (key, dict1[key]))print(&quot;*&quot; * 50)for value in dict1.values(): print(&quot;value: &quot;, value)print(&quot;*&quot; * 50)for key, value in dict1.items(): print(&quot;key: %s, value: %s&quot; % (key, value)) dict的合并123dict2 = &#123;&quot;mobel&quot;: 15888888888, &quot;postal_code&quot;: 10000&#125; # 合并两个dictdict1.update(dict2)print(&quot;dict1: &quot;, dict1) dict和list的异同 list查找和插入的时间随着元素的增加而增加；占用空间小，浪费内存很少 dict查找和插入的速度极快，不会随着key的增加而变慢；需要占用大量的内存，内存浪费多。所以，dict是用空间来换取时间的一种方法。 dict的排序1234567891011121314151617181920212223# dict排序dict3 = &#123;&#x27;sh&#x27;: 3, &#x27;hz&#x27;: 2, &#x27;tj&#x27;: 1, &#x27;bj&#x27;: 5, &#x27;gz&#x27;: 2, &#x27;sz&#x27;: 4, &#x27;wh&#x27;: 1&#125;# 默认排序，并仅返回keykey_rank1 = sorted(dict3.keys(), reverse=False)print(&quot;key_rank1: &quot;, key_rank1)# 默认排序(以key来排序)，并返回key和valuedict_key_rank1 = sorted(dict3.items(), reverse=False)print(&quot;dict_key_rank1: &quot;, dict(dict_key_rank1))# 以key排序dict_key_rank2 = sorted(dict3.items(), key=lambda item: item[0], reverse=False)print(&quot;dict_key_rank2: &quot;, dict(dict_key_rank2))# 以value排序dict_value_rank1 = sorted(dict3.items(), key=lambda item: item[1], reverse=False)print(&quot;dict_value_rank1: &quot;, dict(dict_value_rank1))# 以value排序dict4 = &#123;&#x27;上海&#x27;: 3, &#x27;杭州&#x27;: 2, &#x27;天津&#x27;: 1, &#x27;北京&#x27;: 5, &#x27;广州&#x27;: 2, &#x27;深圳&#x27;: 4, &#x27;武汉&#x27;: 1&#125;dict_value_rank2 = sorted(dict4.items(), key=lambda item: item[1], reverse=True)print(&quot;dict_value_rank2: &quot;, dict(dict_value_rank2)) tuple元组( )tuple是**==不可变==、==有序==**的列表，所以一般在定义tuple时就进行初始化赋值。 注意： 在定义只有一个元素的tuple时其元素后面要加逗号 123tuple0 = () # 创建空元祖tuple0 = (1) # 不是tuple，会当成括号处理tuple0 = (1,) # 正确的tuple tuple虽然不可变但tuple中的元素对象却是可变的 12345my_list = [&quot;x&quot;, &quot;y&quot;]tuple1 = (&#x27;a&#x27;, &#x27;b&#x27;, my_list) # tuple包含list,list变化时,tuple1也就跟着变化print(&quot;tuple1: &quot;, tuple1) # tuple1: (&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;])my_list.append(&quot;z&quot;)print(&quot;tuple1 with my_list changed: &quot;, tuple1) # tuple1变为(&#x27;a&#x27;, &#x27;b&#x27;, [&#x27;x&#x27;, &#x27;y&#x27;, &#x27;z&#x27;]) tuple的创建123tuple2 = (1, &quot;good&quot;, 2, 3, &quot;good&quot;, True) # 创建元组,里面的元素类型可以不同tuple3 = (&quot;a&quot;, &quot;b&quot;, *tuple2, 4, 5) # 元组引用另一个数组中的所有元素print(&quot;tuple3: &quot;, tuple3) tuple中元素的增删改查1234567891011element = tuple2[4] # 根据索引获取元组中的元素element = tuple2[-2] # 使用索引获取元组中的元素index = tuple2.index(&quot;good&quot;) # 获取第一个匹配给定值的index值del tuple2 # 删除元组# tuple2[4] = &quot;well&quot; # 修改元组的元素,报错tuple4 = (&quot;a&quot;, &quot;b&quot;, 4, 5, [6, 7, 8])print(&quot;tuple4: &quot;, tuple4)# tuple4[-1] = [10, 20, 30] #报错tuple4[-1][0] = 100 # 可以通过修改元组中的list,从而改变元组print(&quot;tuple4: &quot;, tuple4) # tuple4: (&#x27;a&#x27;, &#x27;b&#x27;, 4, 5, [100, 7, 8]) tuple的遍历注：tuple的遍历同list","categories":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://hicode360.github.io/tags/python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://hicode360.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"}]},{"title":"git常用命令","slug":"git&sql&docker/git常用命令","date":"2021-09-28T03:05:35.000Z","updated":"2022-11-28T02:34:19.000Z","comments":true,"path":"20210928110535/git&sql&docker/git常用命令/","link":"","permalink":"https://hicode360.github.io/20210928110535/git&sql&docker/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","excerpt":"","text":"git常用命令123456789101112131415161718192021222324252627282930git clone https://github.com/username/project.github.io.git #拉取代码(master/main)git clone -b _dev https://github.com/username/project.github.io.git #拉取分支(非master或main分支)git checkout --track origin/_remote #获取指定的远程分支到本地git branch #查看本地分支git branch -a #查看远程分支git branch -vv#查看分支的绑定信息git branch _local #创建本地分支git branch -d _local #删除本地分支(当前分支不能停留在要删除的分支上)git checkout _local #切换到本地分支git checkout -b _local # 创建并切换到本地创建的分支git push --set-upstream origin _remote #创建远程分支git branch -r -d origin/_remote #删除远程分支(记得push一下 git push origin _remote)git checkout -b _local origin/_remote #创建本地分支绑定远程分支git status #查看修改过代码的类git diff #查看修改的代码git add src/main/java/com/so/alg/RecommendServiceImpl.java #添加修改的代码git commit -m &quot;recommend feed modified&quot; #给修改的代码添加注释git pull origin _remote #从远程更新变动的代码git push origin _local:_remote #提交git merge _remote #合并分支到master上(需要先切换到master分支上,在执行合并)git tag -a 2020071801 -m &#x27;v2.0部署&#x27; #添加taggit show 2020071801 #展示taggit push --tags #提交tag git配置SSH公钥和私钥1234567891011121314151617# 1.生成公钥和私钥(邮箱为github注册邮箱)ssh-keygen -t rsa -C &quot;xxxxxx@gmail.com&quot;# 2.设置公钥私钥key的保存位置(可以直接确认则保存在默认位置)Generating public/private rsa key pair.Enter file in which to save the key (/Users/username/.ssh/id_rsa):# 3.输入、重复输入密钥盐值Enter passphrase (empty for no passphrase):Enter same passphrase again:# 4.复制打印的公钥内容，并在github-&gt;Settings-&gt;SSH and GPG keys-&gt;New SSH Key中设置(title随意起)cat .ssh\\id_rsa.pub# 5.查看密钥是否配置成功(会提示输入盐值)ssh -T git@github.comEnter passphrase for key &#x27;/Users/username/.ssh/id_rsa&#x27;:Hi hicode360! You&#x27;ve successfully authenticated, but GitHub does not provide shell access.# 6.配置全局git信息git config --global user.name &quot;username&quot; # github用户名git config --global user.email &quot;xxxxxx@gmail.com&quot; #github注册邮箱","categories":[{"name":"git","slug":"git","permalink":"https://hicode360.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://hicode360.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://hicode360.github.io/tags/%E5%91%BD%E4%BB%A4/"}]},{"title":"linux文件压缩、解压、打包、解包命令总结","slug":"linux/linux文件压缩、解压、打包、解包命令","date":"2021-09-27T10:26:29.000Z","updated":"2022-11-28T02:34:32.000Z","comments":true,"path":"20210927182629/linux/linux文件压缩、解压、打包、解包命令/","link":"","permalink":"https://hicode360.github.io/20210927182629/linux/linux%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9%E3%80%81%E8%A7%A3%E5%8E%8B%E3%80%81%E6%89%93%E5%8C%85%E3%80%81%E8%A7%A3%E5%8C%85%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件压缩、解压、打包、解包zip压缩/unzip解压zip/unzip [参数] 被压缩文件 参数： 参数 含义 -r 压缩所有子目录 -d 解压 命令 # 压缩成zip文件(其中havorld.zip中的.zip可以省略，默认扩展名为zip) zip -r havorld.zip ./havorld/* # 解压zip文件到指定目录 unzip -d /home/havorld havorld.zip 注：zip既能压缩文件又能压缩目录 gzip压缩/解压gzip使用格式： gzip [参数] 被压缩文件 参数： 参数 含义 -r 压缩所有子目录 -d 解压 命令 gzip havorld.txt # 压缩指定文件 ,生成havorld.txt.tar.gz gzip -r havorld.tar havorld.tar.gz # 压缩文件 gzip havorld.tar # 压缩打包文件，生成havorld.tar.gz gzip -d havorld.tar.gz # 解压文件 注：gzip只能压缩文件不能压缩目录 打包(归档)/解包 tar 数据备份：把一系列文件打包到一个大文件中 恢复数据：把档案文件数据解包 tar使用格式： tar [参数] 打包文件名 文件 参数： 参数 含义 -c 生成档案文件，创建打包文件 -v 列出打包解档的详细过程，显示进度 -f 指定档案文件名称，f后面一定是.tar文件，所以必须放选项最后 -t 列出档案中包含的文件 -x 解开档案文件 注：参数前面的 “-“ 也加可不加 命令： # 打包指定文件,生成.tar文件 tar -cvf havorld.tar havorld.txt meng.log # 打包文件havorld目录下的所有文件,生成.tar文件 tar -cvf havorld.tar ./havorld* # 解包.tar的文件 tar -xvf havorld.tar 注：tar只负责打包文件但不压缩，在tar命令中增加一个参数(-z)调用gzip实现打包+压缩的功能，其扩展名一般为.tar.gz # 打包+压缩指定文件,生成.tar.gz文件 tar -cvzf havorld.tar.gz havorld.txt meng.log # 打包+压缩havorld目录下的所有文件,生成.tar.gz文件 tar -cvzf havorld.tar.gz ./havorld* # 解压缩+解包.tar.gz的文件到指定目录 tar -zxvf havorld.tar.gz -C /home/havorld bzip2压缩/bunzip2解压由于 bzip2 与 gzip 相比，其压缩稳定性和效果都更好，用法跟gzip一样 bzip2 havorld.txt # 生成havorld.txt.bz2 bzip2 -k havorld.txt # 生成havorld.txt.bz2，并保留源文件 bunzip2 havorld.txt # 生成havorld.txt.bz2 bunzip2 -k havorld.txt # 生成havorld.txt.bz2，并保留源文件 tar与bzip2命令结合使用实现文件打包和压缩，其扩展名一般用xxxx.tar.gz2。 在tar命令中增加一个选项(-j)可以调用bzip2实现了一个压缩的功能，实行一个先打包后压缩的过程。 # 打包+压缩指定文件,生成.tar.gz文件 tar -jcvf havorld.tar.bz2 havorld.txt meng.log # 打包+压缩havorld目录下的所有文件,生成.tar.gz文件 tar -jcvf havorld.tar.bz2 ./havorld* # 解压缩+解包.tar.gz的文件到指定目录 tar -jxvf havorld.tar.bz2 -C /home/havorld","categories":[{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/tags/linux/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"},{"name":"文件解压","slug":"文件解压","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B/"}]}],"categories":[{"name":"docker","slug":"docker","permalink":"https://hicode360.github.io/categories/docker/"},{"name":"python","slug":"python","permalink":"https://hicode360.github.io/categories/python/"},{"name":"git","slug":"git","permalink":"https://hicode360.github.io/categories/git/"},{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/categories/linux/"}],"tags":[{"name":"docker","slug":"docker","permalink":"https://hicode360.github.io/tags/docker/"},{"name":"tfserving","slug":"tfserving","permalink":"https://hicode360.github.io/tags/tfserving/"},{"name":"python","slug":"python","permalink":"https://hicode360.github.io/tags/python/"},{"name":"数据类型","slug":"数据类型","permalink":"https://hicode360.github.io/tags/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"name":"git","slug":"git","permalink":"https://hicode360.github.io/tags/git/"},{"name":"命令","slug":"命令","permalink":"https://hicode360.github.io/tags/%E5%91%BD%E4%BB%A4/"},{"name":"linux","slug":"linux","permalink":"https://hicode360.github.io/tags/linux/"},{"name":"文件压缩","slug":"文件压缩","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E5%8E%8B%E7%BC%A9/"},{"name":"文件解压","slug":"文件解压","permalink":"https://hicode360.github.io/tags/%E6%96%87%E4%BB%B6%E8%A7%A3%E5%8E%8B/"}]}